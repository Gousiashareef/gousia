//var moment=require('moment');

var fs = require('fs');
var crypto = require('crypto');
var f;
var s = 0;
var k;
var link1;
var data=fs.readFileSync(__dirname + '/../../../models/dblink.json');
var dblink=JSON.parse(data);

var bodyparser = require('body-parser');
var Base64Id = function () {};
Base64Id.prototype.getRandomBytes = function (bytes) {

  var BUFFER_SIZE = 4096
  var self = this;

  bytes = bytes || 12;

  if (bytes > BUFFER_SIZE) {
    return crypto.randomBytes(bytes);
  }

  var bytesInBuffer = parseInt(BUFFER_SIZE / bytes);
  var threshold = parseInt(bytesInBuffer * 0.85);

  if (!threshold) {
    return crypto.randomBytes(bytes);
  }

  if (this.bytesBufferIndex == null) {
    this.bytesBufferIndex = -1;
  }

  if (this.bytesBufferIndex == bytesInBuffer) {
    this.bytesBuffer = null;
    this.bytesBufferIndex = -1;
  }

  // No buffered bytes available or index above threshold
  if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {

    if (!this.isGeneratingBytes) {
      this.isGeneratingBytes = true;
      crypto.randomBytes(BUFFER_SIZE, function (err, bytes) {
        self.bytesBuffer = bytes;
        self.bytesBufferIndex = 0;
        self.isGeneratingBytes = false;
      });
    }

    // Fall back to sync call when no buffered bytes are available
    if (this.bytesBufferIndex == -1) {
      return crypto.randomBytes(bytes);
    }
  }

  var result = this.bytesBuffer.slice(bytes * this.bytesBufferIndex, bytes * (this.bytesBufferIndex + 1));
  this.bytesBufferIndex++;

  return result;
}
//sleep.sleep(5);
Base64Id.prototype.generateId = function () {


  //var mon=require('/home/gousia/Desktop/liii/node_modules/base64id/lib/mongoq.js');
var data=fs.readFileSync(__dirname + '/../../../models/dblink.json');
var dblink=JSON.parse(data);
var w=dblink.length;
for(var i=0;i<w;i++)
{
  console.log('1');
  
  var f1=0;

 var linkadd= dblink[0].link;
dblink.splice(dblink[0].link,1);
  fs.writeFileSync(__dirname + '/../../../models/dblink.json', JSON.stringify(dblink), function(err){
   if(err) console.log(err);

  });

}

  



    //console.log(linkadd);
  if(f1==0)
{
  console.log('2');
  f1++;

  console.log(linkadd);
  return linkadd;
  }

else
{
console.log('3');
  var rand = new Buffer(15); // multiple of 3 for base64
  if (!rand.writeInt32BE) {
    return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString()
      + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();
  }
  this.sequenceNumber = (this.sequenceNumber + 1) | 0;
  rand.writeInt32BE(this.sequenceNumber, 11);
  if (crypto.randomBytes) {
    this.getRandomBytes(12).copy(rand);
  } else {
    // not secure for node 0.4
    [0, 4, 8].forEach(function(i) {
      rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i);
    });
  }

return rand.toString('base64').replace(/\//g, '_').replace(/\+/g, '-');
}
};



//return 'zi7V2rcUILWip3a3AAAA';


/**
 * Export
 */
 exports = module.exports = new Base64Id();
