/*!
 * base64id v0.1.0
 */

/**
 * Module dependencies
 */
 
//var moment=require('moment');
var async=require('async');
var sleep = require('sleep');
var fs=require('fs');
var Promise=require('promise');
var mongoose=require('mongoose');
var crypto = require('crypto');
var deasync=require('deasync');
var Base64Id = function() { };
var f;
var s=0;
var k;
var link1;
  var Match=require('/home/gousia/Desktop/liii/models/Match.js');
//if(s==0){
//var mon=require('/home/gousia/Desktop/livee/node_modules/base64id/lib/mongoq.js');
//s++;
//}

//var x;
//var k;


Base64Id.prototype.getRandomBytes = function(bytes) {

  var BUFFER_SIZE = 4096
  var self = this;  
  
  bytes = bytes || 12;

  if (bytes > BUFFER_SIZE) {
    return crypto.randomBytes(bytes);
  }
  
  var bytesInBuffer = parseInt(BUFFER_SIZE/bytes);
  var threshold = parseInt(bytesInBuffer*0.85);

  if (!threshold) {
    return crypto.randomBytes(bytes);
  }

  if (this.bytesBufferIndex == null) {
     this.bytesBufferIndex = -1;
  }

  if (this.bytesBufferIndex == bytesInBuffer) {
    this.bytesBuffer = null;
    this.bytesBufferIndex = -1;
  }

  // No buffered bytes available or index above threshold
  if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {
     
    if (!this.isGeneratingBytes) {
      this.isGeneratingBytes = true;
      crypto.randomBytes(BUFFER_SIZE, function(err, bytes) {
        self.bytesBuffer = bytes;
        self.bytesBufferIndex = 0;
        self.isGeneratingBytes = false;
      }); 
    }
    
    // Fall back to sync call when no buffered bytes are available
    if (this.bytesBufferIndex == -1) {
      return crypto.randomBytes(bytes);
    }
  }
  
  var result = this.bytesBuffer.slice(bytes*this.bytesBufferIndex, bytes*(this.bytesBufferIndex+1)); 
  this.bytesBufferIndex++; 
  
  return result;
}
//sleep.sleep(5);
Base64Id.prototype.generateId = function () {


//var mon=require('/home/gousia/Desktop/liii/node_modules/base64id/lib/mongoq.js');
  var Match=require('/home/gousia/Desktop/liii/models/Match.js');

  Match.matching.find({},function (err,mach){
    if(err) {
      return console.log(err);
    }
    

   k=mach.length;
     if(mach.length){
      
      console.log(mach[0].toObject().link);
     link1=mach[0].toObject().link;

 }
  
}).select({"link":1,"_id":0});


console.log("jhh"+k);


if(k == 1)
{
  console.log("inb64"+link1);
  return link1;
}
 else if(k==0)
{
  var rand = new Buffer(15); // multiple of 3 for base64
  if (!rand.writeInt32BE) {
    return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString()
      + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();
  }
  this.sequenceNumber = (this.sequenceNumber + 1) | 0;
  rand.writeInt32BE(this.sequenceNumber, 11);
  if (crypto.randomBytes) {
    this.getRandomBytes(12).copy(rand);
  } else {
    // not secure for node 0.4
    [0, 4, 8].forEach(function(i) {
      rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i);
    });
  }
  
return rand.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/\=/g,''); 
} 
  
else
{
  sleep.sleep(2);

  }


 };  

 
// return '1ert23';
 
/**
 * Export
 */
exports = module.exports = new Base64Id();
